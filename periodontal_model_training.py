# -*- coding: utf-8 -*-
"""Periodontal_model_training

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/131bYN0TTXg0vhoJ5Tu471r21X_flSHGN
"""

import zipfile
import os

#Path to the zip file
zip_path = "final_dataset.zip"

#Destination folder for zipfile extraction
extract_to = "final_dataset"

os.makedirs(extract_to, exist_ok=True)

#Extract the zip file
with zipfile.ZipFile(zip_path, 'r') as zip_ref:
    zip_ref.extractall(extract_to)

print(f"Unzipped to: {extract_to}")

!pip install ultralytics

from ultralytics import YOLO

#Load the pretrained model
model = YOLO("yolo11m-cls.pt")

#Train the model (first starting with epochs 10)
results = model.train(data="final_dataset", epochs=10, imgsz=64, batch=8)

from ultralytics import YOLO

#Load the pretrained classification model
model = YOLO("yolo11m-cls.pt")

#After resulsts from epochs 10, Train with improved settings
results = model.train(
    data="final_dataset",
    epochs=20,                # More training time
    imgsz=128,                # Higher resolution images
    batch=8,                  # Same batch size
    lr0=0.0005,               # Lower learning rate for stability
    patience=5,               # Early stopping if no improvement
    save_period=1,            # Save model after each epoch
    project="cavity_classification_improved",  # Custom logging folder
    name="YOLOv5s_augmented_run"
)

from ultralytics import YOLO

#Load the pre-trained YOLOv5 classification model
model = YOLO("yolo11m-cls.pt")

#After the previous model stopped at epochs, Train with 40 epochs and no early stopping
results = model.train(
    data="final_dataset",
    epochs=40,                         # Train for 40 full epochs
    imgsz=128,
    batch=8,                           # Consistent batch size
    lr0=0.0005,                        # Stable learning rate
    patience=0,                        # Disables early stopping
    save_period=1,                     # Save model after every epoch
    project="cavity_classification_final",  # New project folder
    name="YOLOv5s_40epochs_run"       # Run name
)

#After good results at epochs 40, moving on to adding Grad-CAM to visualize model reasoning
#Step 1: Install Required Libraries
!pip install grad-cam
!pip install opencv-python

#Load the pretrained YOLOv5s Model
from ultralytics import YOLO

#Load the best model
model = YOLO("cavity_classification_final/YOLOv5s_40epochs_run/weights/best.pt")

#Load and Preprocess an Image
import cv2
import matplotlib.pyplot as plt

#Choose an image from the test set
img_path = "/content/final_dataset/test/with_cavity/Cavity-1000-_jpg.rf.ada89b7d3f7cae90f5b8fde1654f9ae8.jpg"

#Load image and convert to RGB
img = cv2.imread(img_path)
img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

plt.imshow(img)
plt.title("Original Dental X-ray")
plt.axis("off")
plt.show()

from pytorch_grad_cam import GradCAM
from pytorch_grad_cam.utils.model_targets import ClassifierOutputTarget
from pytorch_grad_cam.utils.image import show_cam_on_image, preprocess_image
import numpy as np
import torch

#Normalize image and convert to input tensor
img_float = img.astype(np.float32) / 255.0
input_tensor = preprocess_image(
    img_float,
    mean=[0.485, 0.456, 0.406],
    std=[0.229, 0.224, 0.225]
)

#Make input_tensor require gradients
input_tensor = input_tensor.clone().detach().requires_grad_(True)

#Access the internal PyTorch model from YOLO
pt_model = model.model

#Identify the last convolutional layer
target_layers = [pt_model.model[-2]]

#Initialize Grad-CAM
cam = GradCAM(model=pt_model, target_layers=target_layers)

#Set target class: 1 = with cavity, 0 = without cavity
targets = [ClassifierOutputTarget(1)]

#Generate the Grad-CAM heatmap
grayscale_cam = cam(input_tensor=input_tensor, targets=targets)[0, :]
visualization = show_cam_on_image(img_float, grayscale_cam, use_rgb=True)

# Display result
plt.imshow(visualization)
plt.title("Grad-CAM Heatmap - Cavity Detection")
plt.axis("off")
plt.show()

#Saving the gradcam image
output_path = "/content/gradcam_cavity_detection.png"
cv2.imwrite(output_path, cv2.cvtColor(visualization, cv2.COLOR_RGB2BGR))
print(f"Saved to: {output_path}")

#Testing on more images automatically(loop over images)

import glob

image_paths = glob.glob("/content/final_dataset/test/with_cavity/*.jpg")

for path in image_paths[:5]:  # limit to first 5
    img = cv2.imread(path)
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    img_float = img.astype(np.float32) / 255.0

    #Make input_tensor require gradients inside the loop:
    input_tensor = preprocess_image(img_float, mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
    input_tensor = input_tensor.clone().detach().requires_grad_(True) # moved inside loop.

    grayscale_cam = cam(input_tensor=input_tensor, targets=[ClassifierOutputTarget(1)])[0, :]
    result = show_cam_on_image(img_float, grayscale_cam, use_rgb=True)

    output_file = f"/content/gradcam_{path.split('/')[-1]}"
    cv2.imwrite(output_file, cv2.cvtColor(result, cv2.COLOR_RGB2BGR))
    print(f"Saved: {output_file}")